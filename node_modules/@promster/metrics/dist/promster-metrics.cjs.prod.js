'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var once = require('lodash.once');
var Prometheus = require('prom-client');
var merge = require('merge-options');
var requireOptional = require('optional');
var url = require('url');
var UrlValueParser = require('url-value-parser');

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var once__default = /*#__PURE__*/_interopDefault(once);
var Prometheus__namespace = /*#__PURE__*/_interopNamespace(Prometheus);
var merge__default = /*#__PURE__*/_interopDefault(merge);
var requireOptional__default = /*#__PURE__*/_interopDefault(requireOptional);
var url__default = /*#__PURE__*/_interopDefault(url);
var UrlValueParser__default = /*#__PURE__*/_interopDefault(UrlValueParser);

const isRunningInKubernetes = () => Boolean(process.env.KUBERNETES_SERVICE_HOST);

const skipMetricsInEnvironment = options => options.detectKubernetes === true && !isRunningInKubernetes();

// NOTE:
//   This is the `globalRegistry` provided by the `prom-client`
//   We could create multiple registries with `new Prometheus.registry()`.
const defaultRegister = Prometheus__namespace.register;

// eslint-disable-next-line @typescript-eslint/consistent-type-definitions

const configure = once__default["default"](options => {
  const shouldSkipMetricsInEnvironment = skipMetricsInEnvironment(options);
  if (!shouldSkipMetricsInEnvironment) {
    Prometheus__namespace.collectDefaultMetrics(options);
  }
});

const defaultHttpRequestDurationPercentileInSeconds = [0.5, 0.9, 0.95, 0.98, 0.99];
const defaultHttpRequestDurationInSeconds = [0.05, 0.1, 0.3, 0.5, 0.8, 1, 1.5, 2, 3, 10];
const defaultHttpContentLengthInBytes = [100000, 200000, 500000, 1000000, 1500000, 2000000, 3000000, 5000000, 10000000];
const defaultLabels$2 = ['path', 'status_code', 'method'];
const asArray$2 = maybeArray => Array.isArray(maybeArray) ? maybeArray : [maybeArray];
const shouldObserveHttpRequestsAsSummary = options => options.metricTypes.includes('httpRequestsSummary');
const shouldObserveHttpRequestsAsHistogram = options => options.metricTypes.includes('httpRequestsHistogram');
const shouldObserveHttpRequestsAsCounter = options => options.metricTypes.includes('httpRequestsTotal');
const shouldObserveHttpContentLengthAsHistogram = options => options.metricTypes.includes('httpContentLengthHistogram');
const defaultOptions$4 = {
  getLabelValues: () => ({}),
  labels: [],
  metricPrefix: '',
  metricTypes: ['httpRequestsTotal', 'httpRequestsHistogram'],
  metricNames: {
    httpRequestsTotal: ['http_requests_total'],
    httpRequestDurationPerPercentileInSeconds: ['http_request_duration_per_percentile_seconds'],
    httpRequestDurationInSeconds: ['http_request_duration_seconds'],
    httpRequestContentLengthInBytes: ['http_request_content_length_bytes'],
    httpResponseContentLengthInBytes: ['http_response_content_length_bytes']
  }
};
const getMetrics$2 = options => ({
  httpRequestContentLengthInBytes: shouldObserveHttpContentLengthAsHistogram(options) ? asArray$2(options.metricNames.httpRequestContentLengthInBytes).map(nameOfHttpContentLengthMetric => new Prometheus__namespace.Histogram({
    name: `${options.metricPrefix}${nameOfHttpContentLengthMetric}`,
    help: 'The HTTP request content length in bytes.',
    labelNames: defaultLabels$2.concat(options.labels).sort(),
    buckets: options.buckets || defaultHttpContentLengthInBytes
  })) : undefined,
  httpResponseContentLengthInBytes: shouldObserveHttpContentLengthAsHistogram(options) ? asArray$2(options.metricNames.httpResponseContentLengthInBytes).map(nameOfHttpContentLengthMetric => new Prometheus__namespace.Histogram({
    name: `${options.metricPrefix}${nameOfHttpContentLengthMetric}`,
    help: 'The HTTP response content length in bytes.',
    labelNames: defaultLabels$2.concat(options.labels).sort(),
    buckets: options.buckets || defaultHttpContentLengthInBytes
  })) : undefined
});
const getHttpRequestLatencyMetricsInSeconds = options => ({
  httpRequestDurationPerPercentileInSeconds: shouldObserveHttpRequestsAsSummary(options) ? asArray$2(options.metricNames.httpRequestDurationPerPercentileInSeconds).map(nameOfHttpRequestDurationPerPercentileInSeconds => new Prometheus__namespace.Summary({
    name: `${options.metricPrefix}${nameOfHttpRequestDurationPerPercentileInSeconds}`,
    help: 'The HTTP request latencies in seconds.',
    labelNames: defaultLabels$2.concat(options.labels).sort(),
    percentiles: options.percentiles || defaultHttpRequestDurationPercentileInSeconds
  })) : undefined,
  httpRequestDurationInSeconds: shouldObserveHttpRequestsAsHistogram(options) ? asArray$2(options.metricNames.httpRequestDurationInSeconds).map(nameOfHttpRequestDurationInSecondsMetric => new Prometheus__namespace.Histogram({
    name: `${options.metricPrefix}${nameOfHttpRequestDurationInSecondsMetric}`,
    help: 'The HTTP request latencies in seconds.',
    labelNames: defaultLabels$2.concat(options.labels).sort(),
    buckets: options.buckets || defaultHttpRequestDurationInSeconds
  })) : undefined
});
const getHttpRequestCounterMetric = options => ({
  httpRequestsTotal: shouldObserveHttpRequestsAsCounter(options) ? asArray$2(options.metricNames.httpRequestsTotal).map(nameOfHttpRequestsTotalMetric => new Prometheus__namespace.Counter({
    name: `${options.metricPrefix}${nameOfHttpRequestsTotalMetric}`,
    help: 'The total HTTP requests.',
    labelNames: defaultLabels$2.concat(options.labels).sort()
  })) : undefined
});
const createHttpMetrics = options => {
  const defaultedOptions = merge__default["default"](defaultOptions$4, options);
  configure({
    prefix: defaultedOptions.metricPrefix
  });
  const metrics = getMetrics$2(defaultedOptions);
  const httpRequestLatencyMetricsInSeconds = getHttpRequestLatencyMetricsInSeconds(defaultedOptions);
  const httpRequestCounterMetric = getHttpRequestCounterMetric(defaultedOptions);
  return Object.assign({}, metrics, httpRequestLatencyMetricsInSeconds, httpRequestCounterMetric);
};
createHttpMetrics.defaultOptions = defaultOptions$4;

const defaultGraphQlPercentiles = [0.5, 0.9, 0.95, 0.98, 0.99];
const defaultLabels$1 = ['operation_name'];
const asArray$1 = maybeArray => Array.isArray(maybeArray) ? maybeArray : [maybeArray];
const shouldObserveGraphQlParseDurationAsHistogram = options => options.metricTypes.includes('graphQlParseDurationHistogram');
const shouldObserveGraphQlValidationDurationAsHistogram = options => options.metricTypes.includes('graphQlValidationDurationHistogram');
const shouldObserveGraphQlResolveFieldDurationAsHistogram = options => options.metricTypes.includes('graphQlResolveFieldDurationHistogram');
const shouldObserveGraphQlRequestDurationAsHistogram = options => options.metricTypes.includes('graphQlRequestDurationHistogram');
const shouldObserveGraphQlErrorsTotalAsCounter = options => options.metricTypes.includes('graphQlErrorsTotal');
const defaultOptions$3 = {
  getLabelValues: () => ({}),
  labels: [],
  metricPrefix: '',
  metricTypes: ['graphQlParseDurationHistogram', 'graphQlValidationDurationHistogram', 'graphQlResolveFieldDurationHistogram', 'graphQlRequestDurationHistogram', 'graphQlErrorsTotal'],
  metricNames: {
    graphQlParseDuration: ['graphql_parse_duration_seconds'],
    graphQlValidationDuration: ['graphql_validation_duration_seconds'],
    graphQlResolveFieldDuration: ['graphql_resolve_field_duration_seconds'],
    graphQlRequestDuration: ['graphql_request_duration_seconds'],
    graphQlErrorsTotal: ['graphql_errors_total']
  }
};
const getMetrics$1 = options => ({
  graphQlParseDuration: shouldObserveGraphQlParseDurationAsHistogram(options) ? asArray$1(options.metricNames.graphQlParseDuration).map(nameOfGraphQlParseDuration => new Prometheus__namespace.Histogram({
    name: `${options.metricPrefix}${nameOfGraphQlParseDuration}`,
    help: 'The GraphQL request parse time in seconds.',
    labelNames: defaultLabels$1.concat(options.labels).sort(),
    buckets: options.buckets || defaultGraphQlPercentiles
  })) : undefined,
  graphQlValidationDuration: shouldObserveGraphQlValidationDurationAsHistogram(options) ? asArray$1(options.metricNames.graphQlValidationDuration).map(nameOfGraphQlValidationDuration => new Prometheus__namespace.Histogram({
    name: `${options.metricPrefix}${nameOfGraphQlValidationDuration}`,
    help: 'The GraphQL request validation time in seconds.',
    labelNames: defaultLabels$1.concat(options.labels).sort(),
    buckets: options.buckets || defaultGraphQlPercentiles
  })) : undefined,
  graphQlResolveFieldDuration: shouldObserveGraphQlResolveFieldDurationAsHistogram(options) ? asArray$1(options.metricNames.graphQlResolveFieldDuration).map(nameOfGraphQlResolveFieldDuration => new Prometheus__namespace.Histogram({
    name: `${options.metricPrefix}${nameOfGraphQlResolveFieldDuration}`,
    help: 'The GraphQL field resolving time in seconds.',
    labelNames: defaultLabels$1.concat(['field_name']).concat(options.labels).sort(),
    buckets: options.buckets || defaultGraphQlPercentiles
  })) : undefined,
  graphQlRequestDuration: shouldObserveGraphQlRequestDurationAsHistogram(options) ? asArray$1(options.metricNames.graphQlRequestDuration).map(nameOfGraphQlRequestDuration => new Prometheus__namespace.Histogram({
    name: `${options.metricPrefix}${nameOfGraphQlRequestDuration}`,
    help: 'The GraphQL request duration time in seconds.',
    labelNames: defaultLabels$1.concat(options.labels).sort(),
    buckets: options.buckets || defaultGraphQlPercentiles
  })) : undefined,
  graphQlErrorsTotal: shouldObserveGraphQlErrorsTotalAsCounter(options) ? asArray$1(options.metricNames.graphQlErrorsTotal).map(nameOfGraphQlErrorsCount => new Prometheus__namespace.Counter({
    name: `${options.metricPrefix}${nameOfGraphQlErrorsCount}`,
    help: 'Count of errors while parsing, validating, or executing a GraphQL operation.',
    labelNames: defaultLabels$1.concat(['phase']).concat(options.labels).sort()
  })) : undefined
});
const createGraphQlMetrics = options => {
  const defaultedOptions = merge__default["default"](defaultOptions$3, options);
  configure({
    prefix: defaultedOptions.metricPrefix
  });
  const metrics = getMetrics$1(defaultedOptions);
  return metrics;
};
createGraphQlMetrics.defaultOptions = defaultOptions$3;

const defaultLabels = ['gc_type'];
const asArray = maybeArray => Array.isArray(maybeArray) ? maybeArray : [maybeArray];
const defaultOptions$2 = {
  getLabelValues: () => ({}),
  labels: [],
  metricPrefix: '',
  metricNames: {
    up: ['up'],
    countOfGcs: ['nodejs_gc_runs_total'],
    durationOfGc: ['nodejs_gc_pause_seconds_total'],
    reclaimedInGc: ['nodejs_gc_reclaimed_bytes_total']
  }
};
const getMetrics = options => ({
  up: asArray(options.metricNames.up).map(nameOfUpMetric => new Prometheus__namespace.Gauge({
    name: `${options.metricPrefix}${nameOfUpMetric}`,
    help: '1 = up, 0 = not up'
  })),
  countOfGcs: asArray(options.metricNames.countOfGcs).map(nameOfCountOfGcsMetric => new Prometheus__namespace.Counter({
    name: `${options.metricPrefix}${nameOfCountOfGcsMetric}`,
    help: 'Count of total garbage collections.',
    labelNames: defaultLabels
  })),
  durationOfGc: asArray(options.metricNames.durationOfGc).map(nameOfDurationOfGcMetric => new Prometheus__namespace.Counter({
    name: `${options.metricPrefix}${nameOfDurationOfGcMetric}`,
    help: 'Time spent in GC Pause in seconds.',
    labelNames: defaultLabels
  })),
  reclaimedInGc: asArray(options.metricNames.reclaimedInGc).map(nameOfReclaimedInGcMetric => new Prometheus__namespace.Counter({
    name: `${options.metricPrefix}${nameOfReclaimedInGcMetric}`,
    help: 'Total number of bytes reclaimed by GC.',
    labelNames: defaultLabels
  }))
});
const createGcMetrics = options => {
  const defaultedOptions = merge__default["default"](defaultOptions$2, options);
  configure({
    prefix: defaultedOptions.metricPrefix
  });
  const gcMetrics = getMetrics(defaultedOptions);
  return gcMetrics;
};
createGcMetrics.defaultOptions = defaultOptions$2;

const getSummary = async () => defaultRegister.metrics();
const getContentType = () => defaultRegister.contentType;

function sortLabels(unsortedLabels) {
  return Object.keys(unsortedLabels).sort((a, b) => {
    if (a < b) {
      return -1;
    }
    if (a > b) {
      return 1;
    }
    return 0;
  }).reduce((sortedLabels, labelName) => {
    sortedLabels[labelName] = unsortedLabels[labelName];
    return sortedLabels;
  }, {});
}

const NS_PER_SEC = 1e9;
function endMeasurementFrom(start) {
  const [seconds, nanoseconds] = process.hrtime(start);
  return {
    durationS: (seconds * NS_PER_SEC + nanoseconds) / NS_PER_SEC
  };
}

const defaultOptions$1 = {
  skip: () => false,
  detectKubernetes: false
};
function isTiming(timing) {
  return !Array.isArray(timing);
}
const createRequestRecorder = (metrics, options = defaultOptions$1) => {
  const defaultedRecorderOptions = merge__default["default"](defaultOptions$1, options);
  const shouldSkipMetricsByEnvironment = skipMetricsInEnvironment(defaultedRecorderOptions);
  return (timing, recordingOptions) => {
    const durationS = isTiming(timing) ? timing.end().value().seconds : endMeasurementFrom(timing).durationS;
    const labels = sortLabels(recordingOptions.labels);
    if (!shouldSkipMetricsByEnvironment && durationS !== undefined) {
      var _metrics$httpRequestD;
      (_metrics$httpRequestD = metrics.httpRequestDurationInSeconds) === null || _metrics$httpRequestD === void 0 ? void 0 : _metrics$httpRequestD.forEach(httpRequestDurationInSecondsMetricType => {
        httpRequestDurationInSecondsMetricType.observe(labels, durationS);
      });
    }
    if (!shouldSkipMetricsByEnvironment && durationS !== undefined) {
      var _metrics$httpRequestD2;
      (_metrics$httpRequestD2 = metrics.httpRequestDurationPerPercentileInSeconds) === null || _metrics$httpRequestD2 === void 0 ? void 0 : _metrics$httpRequestD2.forEach(httpRequestDurationPerPercentileInSecondsMetricType => {
        httpRequestDurationPerPercentileInSecondsMetricType.observe(labels, durationS);
      });
    }
    if (!shouldSkipMetricsByEnvironment && durationS !== undefined) {
      var _metrics$httpRequests;
      (_metrics$httpRequests = metrics.httpRequestsTotal) === null || _metrics$httpRequests === void 0 ? void 0 : _metrics$httpRequests.forEach(httpRequestsTotalMetricType => {
        httpRequestsTotalMetricType.inc(labels);
      });
    }
    if (recordingOptions.requestContentLength) {
      var _metrics$httpRequestC;
      (_metrics$httpRequestC = metrics.httpRequestContentLengthInBytes) === null || _metrics$httpRequestC === void 0 ? void 0 : _metrics$httpRequestC.forEach(httpRequestContentLengthInBytesMetricType => {
        httpRequestContentLengthInBytesMetricType.observe(labels,
        // @ts-expect-error
        recordingOptions.requestContentLength);
      });
    }
    if (recordingOptions.responseContentLength) {
      var _metrics$httpResponse;
      (_metrics$httpResponse = metrics.httpResponseContentLengthInBytes) === null || _metrics$httpResponse === void 0 ? void 0 : _metrics$httpResponse.forEach(httpResponseContentLengthInBytesMetricType => {
        httpResponseContentLengthInBytesMetricType.observe(labels,
        // @ts-expect-error
        recordingOptions.responseContentLength);
      });
    }
  };
};
createRequestRecorder.defaultOptions = defaultOptions$1;

const gc = requireOptional__default["default"]('@sematext/gc-stats');
const gcTypes = {
  0: 'unknown',
  1: 'scavenge',
  2: 'mark_sweep_compact',
  3: 'scavenge_and_mark_sweep_compact',
  4: 'incremental_marking',
  8: 'weak_phantom',
  15: 'all'
};
const defaultOptions = {
  disableGcMetrics: false
};
const createGcObserver = once__default["default"]((metrics, options) => () => {
  if (typeof gc !== 'function') {
    return;
  }
  if (options.disableGcMetrics) return;
  gc().on('stats', stats => {
    const gcType = gcTypes[stats.gctype];
    metrics.countOfGcs.forEach(countOfGcMetricType => {
      countOfGcMetricType.labels(gcType).inc();
    });
    metrics.durationOfGc.forEach(durationOfGcMetricType => {
      durationOfGcMetricType.labels(gcType).inc(stats.pause / 1e9);
    });
    if (stats.diff.usedHeapSize < 0) {
      metrics.reclaimedInGc.forEach(reclaimedInGcMetricType => {
        reclaimedInGcMetricType.labels(gcType).inc(stats.diff.usedHeapSize * -1);
      });
    }
  });
});
createGcObserver.defaultOptions = defaultOptions;

const normalizeStatusCode = statusCode => statusCode;

const urlValueParser = new UrlValueParser__default["default"]();
const normalizePath = path => urlValueParser.replacePathValues(url__default["default"].parse(path).pathname, '#val');

const normalizeMethod = method => method.toLowerCase();

const defaultNormalizers = {
  normalizeStatusCode,
  normalizePath,
  normalizeMethod
};

class Timing {
  static NS_PER_SEC = BigInt(1e9);
  #startTime;
  #endTime;
  constructor() {
    this.reset();
  }
  value() {
    const startTime = this.#startTime;
    const endTime = this.#endTime;
    if (!endTime || !startTime) return {
      seconds: undefined
    };
    return {
      seconds: Number(endTime - startTime) / Number(Timing.NS_PER_SEC)
    };
  }
  reset() {
    this.#startTime = process.hrtime.bigint();
    this.#endTime = undefined;
    return this;
  }
  end() {
    this.#endTime = process.hrtime.bigint();
    return this;
  }
}
const timing = {
  start() {
    return new Timing();
  }
};

exports.Prometheus = Prometheus__namespace;
exports.createGcMetrics = createGcMetrics;
exports.createGcObserver = createGcObserver;
exports.createGraphQlMetrics = createGraphQlMetrics;
exports.createHttpMetrics = createHttpMetrics;
exports.createRequestRecorder = createRequestRecorder;
exports.defaultNormalizers = defaultNormalizers;
exports.defaultRegister = defaultRegister;
exports.endMeasurementFrom = endMeasurementFrom;
exports.getContentType = getContentType;
exports.getSummary = getSummary;
exports.isRunningInKubernetes = isRunningInKubernetes;
exports.normalizeMethod = normalizeMethod;
exports.normalizePath = normalizePath;
exports.normalizeStatusCode = normalizeStatusCode;
exports.skipMetricsInEnvironment = skipMetricsInEnvironment;
exports.sortLabels = sortLabels;
exports.timing = timing;
