'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var semver = require('semver');
var merge = require('merge-options');
var metrics = require('@promster/metrics');

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

var semver__default = /*#__PURE__*/_interopDefault(semver);
var merge__default = /*#__PURE__*/_interopDefault(merge);

var pkg = {
	name: "@promster/hapi",
	version: "8.0.6",
	description: "Hapi server integrations of promster",
	main: "dist/promster-hapi.cjs.js",
	typings: "dist/promster-hapi.cjs.d.ts",
	types: "dist/promster-hapi.cjs.d.ts",
	files: [
		"readme.md",
		"package.json",
		"LICENSE",
		"dist/**",
		"modules/**"
	],
	publishConfig: {
		access: "public"
	},
	engines: {
		node: ">=14",
		npm: ">=6"
	},
	repository: {
		type: "git",
		url: "https://github.com/tdeekens/promster.git",
		directory: "packages/hapi"
	},
	author: "Tobias Deekens <nerd@tdeekens.name>",
	license: "MIT",
	bugs: {
		url: "https://github.com/tdeekens/promster/issues"
	},
	homepage: "https://github.com/tdeekens/promster#readme",
	keywords: [
		"metrics",
		"continousdelivery",
		"prometheus"
	],
	dependencies: {
		"@promster/metrics": "^9.1.6",
		"merge-options": "3.0.4",
		semver: "7.3.8",
		tslib: "2.4.1"
	},
	devDependencies: {
		"@hapi/boom": "9.1.4",
		"@hapi/hapi": "20.2.2",
		"@promster/types": "^3.2.5",
		"@types/hapi__hapi": "20.0.13",
		"parse-prometheus-text-format": "1.1.1"
	}
};

// eslint-disable-next-line @typescript-eslint/consistent-type-definitions

const extractPath = request => request.route.path.replace(/\?/g, '');
const isBoomResponse = response => response.isBoom;
const extractStatusCode = request => {
  const {
    response
  } = request;
  if (!response) {
    return 0;
  }
  if (isBoomResponse(response)) {
    return response.output.statusCode;
  }
  return response.statusCode;
};
let recordRequest;
let upMetric;
const getRequestRecorder = () => recordRequest;
const signalIsUp = () => {
  if (!upMetric) {
    return;
  }
  upMetric.forEach(upMetricType => {
    upMetricType.set(1);
  });
};
const signalIsNotUp = () => {
  if (!upMetric) {
    return;
  }
  upMetric.forEach(upMetricType => {
    upMetricType.set(0);
  });
};
const getAreServerEventsSupported = actualVersion => Boolean(actualVersion && semver__default["default"].satisfies(actualVersion, '>= 17.0.0'));
const getDoesResponseNeedInvocation = actualVersion => Boolean(actualVersion && semver__default["default"].satisfies(actualVersion, '< 17.0.0'));
const createPlugin = ({
  options: pluginOptions
} = {
  options: undefined
}) => {
  const allDefaultedOptions = merge__default["default"](metrics.createHttpMetrics.defaultOptions, metrics.createGcMetrics.defaultOptions, metrics.createRequestRecorder.defaultOptions, metrics.createGcObserver.defaultOptions, metrics.defaultNormalizers, pluginOptions);
  const shouldSkipMetricsByEnvironment = metrics.skipMetricsInEnvironment(allDefaultedOptions);
  const httpMetrics = metrics.createHttpMetrics(allDefaultedOptions);
  const gcMetrics = metrics.createGcMetrics(allDefaultedOptions);
  const observeGc = metrics.createGcObserver(gcMetrics, allDefaultedOptions);
  recordRequest = metrics.createRequestRecorder(httpMetrics, allDefaultedOptions);
  upMetric = gcMetrics === null || gcMetrics === void 0 ? void 0 : gcMetrics.up;
  if (!shouldSkipMetricsByEnvironment) {
    observeGc();
  }
  const plugin = {
    name: pkg.name,
    version: pkg.version,
    // @ts-expect-error
    register(server, _registrationOptions, onRegistrationFinished = () => null) {
      const areServerEventsSupported = getAreServerEventsSupported(server.version);
      const doesResponseNeedInvocation = getDoesResponseNeedInvocation(server.version);
      const onRequestHandler = (request, h) => {
        request.plugins.promster = {
          timing: metrics.timing.start()
        };
        // @ts-expect-error
        return doesResponseNeedInvocation ? h.continue() : h.continue;
      };
      const onResponseHandler = (request, response) => {
        var _allDefaultedOptions$, _request$headers$cont, _request$headers, _request$response$hea, _request$response, _request$response$hea2, _allDefaultedOptions$2;
        const labels = Object.assign({}, {
          path: allDefaultedOptions.normalizePath(extractPath(request), {
            req: request,
            res: response
          }),
          method: allDefaultedOptions.normalizeMethod(request.method, {
            req: request,
            res: response
          }),
          status_code: allDefaultedOptions.normalizeStatusCode(extractStatusCode(request), {
            req: request,
            res: response
          })
        }, (_allDefaultedOptions$ = allDefaultedOptions.getLabelValues) === null || _allDefaultedOptions$ === void 0 ? void 0 : _allDefaultedOptions$.call(allDefaultedOptions, request, {}));
        const requestContentLength = Number((_request$headers$cont = request === null || request === void 0 ? void 0 : (_request$headers = request.headers) === null || _request$headers === void 0 ? void 0 : _request$headers['content-length']) !== null && _request$headers$cont !== void 0 ? _request$headers$cont : 0);
        const responseContentLength = Number( // @ts-expect-error
        (_request$response$hea = request === null || request === void 0 ? void 0 : (_request$response = request.response) === null || _request$response === void 0 ? void 0 : (_request$response$hea2 = _request$response.headers) === null || _request$response$hea2 === void 0 ? void 0 : _request$response$hea2['content-length']) !== null && _request$response$hea !== void 0 ? _request$response$hea : 0);
        const shouldSkipByRequest = (_allDefaultedOptions$2 = allDefaultedOptions.skip) === null || _allDefaultedOptions$2 === void 0 ? void 0 : _allDefaultedOptions$2.call(allDefaultedOptions, request, response, labels);
        if (!shouldSkipByRequest && !shouldSkipMetricsByEnvironment) {
          recordRequest(request.plugins.promster.timing, {
            labels,
            requestContentLength,
            responseContentLength
          });
        }
        if (doesResponseNeedInvocation) response.continue();
      };

      // NOTE: This version detection allows us to gracefully support both new and old Hapi APIs.
      // This is very hard to type as we would have to import two aliased versions of types.
      if (areServerEventsSupported) {
        // @ts-expect-error
        server.ext('onRequest', onRequestHandler);
        // @ts-expect-error
        server.events.on('response', onResponseHandler);
      } else {
        // @ts-expect-error
        server.ext('onRequest', onRequestHandler);
        // @ts-expect-error
        server.ext('onPreResponse', onResponseHandler);
      }

      // NOTE: The type of the server.decorate only supports a function signature,
      // even when the docs state that it can also be "other value" in the case of `server`.
      // @ts-expect-error
      server.decorate('server', 'Prometheus', metrics.Prometheus);
      server.decorate('server', 'recordRequest', recordRequest);
      return onRegistrationFinished === null || onRegistrationFinished === void 0 ? void 0 : onRegistrationFinished();
    }
  };
  // @ts-expect-error
  plugin.register.attributes = {
    pkg
  };
  return plugin;
};

const instrument = async (server, options) => server.register(createPlugin({
  options
}));

Object.defineProperty(exports, 'Prometheus', {
  enumerable: true,
  get: function () { return metrics.Prometheus; }
});
Object.defineProperty(exports, 'defaultNormalizers', {
  enumerable: true,
  get: function () { return metrics.defaultNormalizers; }
});
Object.defineProperty(exports, 'defaultRegister', {
  enumerable: true,
  get: function () { return metrics.defaultRegister; }
});
Object.defineProperty(exports, 'getContentType', {
  enumerable: true,
  get: function () { return metrics.getContentType; }
});
Object.defineProperty(exports, 'getSummary', {
  enumerable: true,
  get: function () { return metrics.getSummary; }
});
Object.defineProperty(exports, 'timing', {
  enumerable: true,
  get: function () { return metrics.timing; }
});
exports.createPlugin = createPlugin;
exports.getRequestRecorder = getRequestRecorder;
exports.instrument = instrument;
exports.signalIsNotUp = signalIsNotUp;
exports.signalIsUp = signalIsUp;
